<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>This used to be about Dungeons - Summary</title>
    <style>
        body {
            font-family: "Open Sans", sans-serif;
            font-size: 16px;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        #chapterControls, #chapterSummary, #about {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        #entityList {
            border-top: 1px solid #ccc;
            padding-top: 20px;
        }
        .entity-item {
            margin-bottom: 15px;
        }
        .entity-item.hidden {
            display: none;
        }
        /* styles.css */
        .light-mode {
            background-color: white;
            color: black;
        }
        .dark-mode {
            font-family: JetBrainsMono, "Courier New", monospace;
            background-color: black;
            color: rgb(0, 204, 0);
        }
        .light-mode button, .light-mode select, .light-mode input {
            background-color: #f0f0f0; /* Light gray background for buttons and selects */
            color: black;
            border: 1px solid #ccc;
        }

        .dark-mode button, .dark-mode select, .dark-mode input {
            background-color: #333; /* Dark gray background for buttons and selects */
            font-family: JetBrainsMono, "Courier New", monospace;
            color: rgb(0, 204, 0);
            border: 1px solid #555;
        }
        </style>
</head>
<body class="light-mode">
    <h1>This used to be about Dungeons - Summary</h1>
    <div id="about">About : The summaries are all autogenerated using a local LLM.  Mistakes and hallucinations are expected.  Cheers - Anton</div>
    <div id="chapterControls">
        
        <button id="toggleTheme">Switch to Hacker Theme</button>
        <div> : </div>
        <button id="firstChapter">First</button>
        <button id="prevChapter">Previous</button>
        <select id="chapterSelector">
            <!-- Chapters will be populated dynamically -->
        </select>
        <button id="nextChapter">Next</button>
        <button id="lastChapter">Last</button>
    </div>

    <h2>Chapter Summary</h2>
    <div id="chapterSummary"></div>

    <h2>Entities up to this chapter</h2>
    <input type="text" id="entitySearch" placeholder="Search entities...">
    <div id="entityList"></div>

    <script>

        const body = document.body;
        const toggleButton = document.getElementById('toggleTheme');
        function setTheme(theme) {
            if (theme === 'dark') {
                body.classList.remove('light-mode');
                body.classList.add('dark-mode');
                localStorage.setItem('theme', 'dark');
                toggleButton.innerHTML = 'Switch to Light theme';
            } else {
                body.classList.remove('dark-mode');
                body.classList.add('light-mode');
                localStorage.setItem('theme', 'light');
                toggleButton.innerHTML = 'Switch to Hacker theme';
            }
        }

        toggleButton.addEventListener('click', () => {
            setTheme(body.classList.contains('light-mode') ? 'dark' : 'light');
        });

        // Check for saved theme preference
        const savedTheme = localStorage.getItem('theme');
        setTheme(savedTheme);

        // Global variable to store the loaded JSON data
        let bookData = [];
        let currentChapterIndex = 0;

        function addFirstChapterToEntities(bookData) {
            // Create a map to track first appearance of entities
            const entityFirstChapter = {};

            // Iterate through all chapters
            bookData.forEach((chapter, chapterIndex) => {
                // Check entities in each chapter
                Object.entries(chapter.entities).forEach(([entityName, entityData]) => {
                    // If this entity hasn't been seen before, record its first chapter
                    if (!entityFirstChapter[entityName]) {
                        entityFirstChapter[entityName] = chapter.chapter;
                    }
                });
            });

            // Update the original bookData with first_chapter
            bookData.forEach(chapter => {
                Object.entries(chapter.entities).forEach(([entityName, entityData]) => {
                    // Add first_chapter to the entity data
                    entityData.first_chapter = entityFirstChapter[entityName];
                });
            });

            return bookData;
        }

        // Fetch the JSON data when the page loads
        async function loadBookData() {
            try {
                const response = await fetch('about_dungeons.json');
                bookData = await response.json();
                bookData = addFirstChapterToEntities(bookData);
                
                // Populate chapter selector
                const chapterSelector = document.getElementById('chapterSelector');
                bookData.forEach((chapter, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `Chapter ${chapter.chapter}`;
                    chapterSelector.appendChild(option);
                });

                // Set initial chapter (first chapter)
                chapterSelector.selectedIndex = 0;
                updateChapterDisplay(0);

                // Add event listeners for navigation
                chapterSelector.addEventListener('change', (e) => {
                    currentChapterIndex = e.target.value;
                    updateChapterDisplay(currentChapterIndex);
                });

                document.getElementById('firstChapter').addEventListener('click', () => {
                        chapterSelector.selectedIndex = 0;
                        currentChapterIndex = chapterSelector.value;
                        updateChapterDisplay(currentChapterIndex);
                });

                document.getElementById('prevChapter').addEventListener('click', () => {
                    if (chapterSelector.selectedIndex > 0) {
                        chapterSelector.selectedIndex--;
                        currentChapterIndex = chapterSelector.value;
                        updateChapterDisplay(currentChapterIndex);
                    }
                });

                document.getElementById('nextChapter').addEventListener('click', () => {
                    if (chapterSelector.selectedIndex < bookData.length - 1) {
                        chapterSelector.selectedIndex++;
                        currentChapterIndex = chapterSelector.value;
                        updateChapterDisplay(currentChapterIndex);
                    }
                });

                document.getElementById('lastChapter').addEventListener('click', () => {
                        chapterSelector.selectedIndex = bookData.length - 1;
                        currentChapterIndex = chapterSelector.value;
                        updateChapterDisplay(currentChapterIndex);
                });

                // Add search event listener
                document.getElementById('entitySearch').addEventListener('input', performEntitySearch);
            } catch (error) {
                console.error('Error loading book data:', error);
            }
        }

        // Convert search input to a flexible regex
        function createSearchRegex(searchTerm) {
            // Escape special regex characters
            let escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            
            // Replace spaces with wild card that matches up to 100 characters
            escapedTerm = escapedTerm.replace(/ /g, '.{0,100}');
            
            // Create case-insensitive regex
            return new RegExp(escapedTerm, 'i');
        }

        // Perform entity search
        function performEntitySearch() {
            const searchInput = document.getElementById('entitySearch').value.trim();
            const entityList = document.getElementById('entityList');
            
            // If search is empty, restore original alphabetical order
            if (searchInput === '') {
                const sortedEntities = Array.from(entityList.children)
                    .sort((a, b) => a.getAttribute('data-entity').localeCompare(b.getAttribute('data-entity')));
                
                // Clear and re-append in sorted order
                entityList.innerHTML = '';
                sortedEntities.forEach(entity => {
                    entity.classList.remove('hidden');
                    entityList.appendChild(entity);
                });
                return;
            }

            // Create search regex
            const searchRegex = createSearchRegex(searchInput);

            // Get current chapter data
            const chapter = bookData[currentChapterIndex];

            // Create an array to store entities with their search scores
            const scoredEntities = [];

            // Calculate scores for each entity
            Object.entries(chapter.entities).forEach(([entityName, entityData]) => {
                let score = -1; // Default to -1 for no match
                let matchLocation = -1;

                // Check entity name
                if (searchRegex.test(entityName)) {
                    matchLocation = entityName.toLowerCase().indexOf(searchInput.toLowerCase());
                    score = 3; // Highest priority for exact name match
                }
                
                // Check aliases
                if (score === -1 && entityData.aliases) {
                    const aliasMatch = entityData.aliases.find(alias => searchRegex.test(alias));
                    if (aliasMatch) {
                        matchLocation = aliasMatch.toLowerCase().indexOf(searchInput.toLowerCase());
                        score = 2; // Second priority for alias match
                    }
                }

                // Check description
                if (score === -1 && searchRegex.test(entityData.description || '')) {
                    matchLocation = (entityData.description || '').toLowerCase().indexOf(searchInput.toLowerCase());
                    score = 1; // Lowest priority for description match
                }

                // If a match is found, add to scored entities
                if (score !== -1) {
                    scoredEntities.push({
                        entityName,
                        entityData,
                        score,
                        matchLocation
                    });
                }
            });

            // Sort scored entities
            scoredEntities.sort((a, b) => {
                // First, sort by score (descending)
                if (a.score !== b.score) {
                    return b.score - a.score;
                }
                // If scores are equal, sort by match location (ascending)
                return a.matchLocation - b.matchLocation;
            });

            // Reorder and filter entities in the DOM
            const sortedEntityNames = scoredEntities.map(entity => entity.entityName);
            
            // Hide non-matching entities and reorder matching ones
            const defaultSortedEntities = Array.from(entityList.children)
                .sort((a, b) => a.getAttribute('data-entity').localeCompare(b.getAttribute('data-entity')));

            // First, restore to default alphabetical order
            entityList.innerHTML = '';
            defaultSortedEntities.forEach(entity => {
                const entityName = entity.getAttribute('data-entity');
                const matchIndex = sortedEntityNames.indexOf(entityName);
                
                if (matchIndex === -1) {
                    entity.classList.add('hidden');
                } else {
                    entity.classList.remove('hidden');
                }
                entityList.appendChild(entity);
            });

            // Then move matched entities to the top while preserving relative order
            sortedEntityNames.forEach(entityName => {
                const matchedEntity = entityList.querySelector(`.entity-item[data-entity="${entityName}"]`);
                if (matchedEntity) {
                    entityList.appendChild(matchedEntity);
                }
            });
        }

        // Update the display for the selected chapter
        function updateChapterDisplay(chapterIndex) {
            const chapter = bookData[chapterIndex];
            
            // Update chapter summary
            document.getElementById('chapterSummary').textContent = chapter.summary;

            // Update entity list
            const entityList = document.getElementById('entityList');
            entityList.innerHTML = ''; // Clear previous entities

            // Sort entities alphabetically
            const sortedEntities = Object.entries(chapter.entities)
                .sort(([a], [b]) => a.localeCompare(b));

            // Create entity items
            sortedEntities.forEach(([entityName, entityData]) => {
                const entityItem = document.createElement('div');
                entityItem.classList.add('entity-item');
                entityItem.setAttribute('data-entity', entityName);
                entityItem.innerHTML = `
                    <strong>${entityName}</strong> (${entityData.type} - First appeared in Chapter ${entityData.first_chapter})<br>
                    ${entityData.description}
                    ${entityData.aliases && entityData.aliases.length > 0 
                        ? `<br><em>Aliases: ${entityData.aliases.join(', ')}</em>` 
                        : ''}
                `;
                entityList.appendChild(entityItem);
            });

            // Apply current search filter to new chapter's entities
            performEntitySearch();
        }

        // Load data when the page loads
        loadBookData();
    </script>
</body>
</html>